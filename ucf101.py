# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S2ZJfMD6WGyPkvOU6spK-OToqTjjEo47
"""

import torch
import torch.utils.data as data
from PIL import Image
import os
import math
import functools
import json
import copy
import pandas as pd
import glob

from utils import load_value_file


def pil_loader(path):
    # open path as file to avoid ResourceWarning (https://github.com/python-pillow/Pillow/issues/835)
    with open(path, 'rb') as f:
        with Image.open(f) as img:
            return img.convert('RGB')


def accimage_loader(path):
    try:
        import accimage
        return accimage.Image(path)
    except IOError:
        # Potentially a decoding problem, fall back to PIL.Image
        return pil_loader(path)


def get_default_image_loader():
    from torchvision import get_image_backend
    if get_image_backend() == 'accimage':
        return accimage_loader
    else:
        return pil_loader


def video_loader(video_dir_path, frame_indices, image_loader):
    video = []
    for i in frame_indices:
        image_path = os.path.join(video_dir_path, 'image_{:05d}.jpg'.format(i))
        if os.path.exists(image_path):
            video.append(image_loader(image_path))
        else:
            return video

    return video


def get_default_video_loader():
    image_loader = get_default_image_loader()
    return functools.partial(video_loader, image_loader=image_loader)

def load_videos_data(data_file_path):
   splitfile = pd.read_table(data_file_path, header = None, sep = " ")
   return splitfile

def get_class_labels(classtxt_path):
    classfile = pd.read_table(classtxt_path, header = None, sep = " ")
    class_labels_map = {}
    for i in range(len(classfile)):
      label = classfile.iloc[i,[0]].values[0]
      classname = classfile.iloc[i,[1]].values[0]
      class_labels_map[classname] = int(label)
    return class_labels_map

def make_dataset(root_path, split_path, split_name, n_samples_for_each_video, sample_duration):
    #get class_to_idx dictionary
    classtxt_path = os.path.join(split_path, "classInd.txt")
    class_to_idx = get_class_labels(classtxt_path)

    #load the file like trainlist01.txt
    splittxt_path = os.path.join(split_path, split_name + ".txt")
    splitfile = load_videos_data(splittxt_path)

    #the returns
    dataset = []

    for i in range(len(splitfile)):
      video_info = splitfile.iloc[i,[0]].values[0].split('/')
      video_class = video_info[0]
      video_name = video_info[1].split('.')[0]
      
      video_path = os.path.join(root_path, video_name)
      n_frames = int(len(glob.glob(video_path+"/img*.jpg")))
      video_label = class_to_idx[video_class]
      begin_t = 1
      end_t = n_frames

      #form
      sample = {'video': video_path,
            'segment': [begin_t, end_t],
            'n_frames': n_frames,
            'label': video_label
            }

      if n_samples_for_each_video == 1:
        sample['frame_indices'] = list(range(1, n_frames + 1))
        dataset.append(sample)
      else:
        if n_samples_for_each_video > 1:
          step = max(1, math.ceil((n_frames - 1 - sample_duration) / (n_samples_for_each_video - 1)))
        else:
          step = sample_duration
          for j in range(1, n_frames, step):
            sample_j = copy.deepcopy(sample)
            sample_j['frame_indices'] = list(range(j, min(n_frames + 1, j + sample_duration)))
      dataset.append(sample_j)

    return dataset, idx_to_class


class UCF101(data.Dataset):
    """
    Args:
        root (string): Root directory path.
        spatial_transform (callable, optional): A function/transform that  takes in an PIL image
            and returns a transformed version. E.g, ``transforms.RandomCrop``
        temporal_transform (callable, optional): A function/transform that  takes in a list of frame indices
            and returns a transformed version
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        loader (callable, optional): A function to load an video given its path and frame indices.
     Attributes:
        classes (list): List of the class names.
        class_to_idx (dict): Dict with items (class_name, class_index).
        imgs (list): List of (image path, class_index) tuples
    """

    def __init__(self,
                 root_path,
                 split_path, 
                 split_name,
                 n_samples_for_each_video=1,
                 spatial_transform=None,
                 temporal_transform=None,
                 sample_duration=16,
                 get_loader=get_default_video_loader):
        self.data, self.class_names = make_dataset(root_path, split_path, split_name, n_samples_for_each_video, sample_duration)

        self.spatial_transform = spatial_transform
        self.temporal_transform = temporal_transform
        self.loader = get_loader()

    def __getitem__(self, index):
        """
        Args:
            index (int): Index
        Returns:
            tuple: (image, target) where target is class_index of the target class.
        """
        path = self.data[index]['video']

        frame_indices = self.data[index]['frame_indices']
        if self.temporal_transform is not None:
            frame_indices = self.temporal_transform(frame_indices)
        clip = self.loader(path, frame_indices)
        if self.spatial_transform is not None:
            self.spatial_transform.randomize_parameters()
            clip = [self.spatial_transform(img) for img in clip]
        clip = torch.stack(clip, 0).permute(1, 0, 2, 3)

        target = self.data[index]['label']

        return clip, target

    def __len__(self):
        return len(self.data)